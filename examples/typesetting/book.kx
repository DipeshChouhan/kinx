using Typesetting;
using typesetting.style.JBookA4;
using MarkdownParser;

namespace Typesetting {

    class InlineMaker {
        var images_ = [];
        private checkInlineParam(paramsText) {
            var res = {};
            paramsText.split(',').each { &(param):
                var e = param.split('=');
                if (e.length() > 1) {
                    res[e[0]] = e[1];
                } else {
                    res[e[0]] = true;
                }
            };
            return res;
        }
        public reset() {
            images_ = [];
        }
        public flush(doc) {
            images_.each { &(image):
                doc.apply(new Typesetting.Component.Image({
                    label: image.opts.label,
                    float: image.opts.float,
                    scale: image.opts.scale ?? 1.0,
                    caption: image.opts.caption,
                    file: image.src,
                }));
            };
            images_ = [];
        }

        public text(value) {
            return value.value;
        }
        public html(value) {
            return '';
        }
        public htmlcomment(value) {
            return '';
        }
        public em(value) {
            return "\\bold{%{value.value}}";
        }
        public italic(value) {
            return value.value;
        }
        public emitalic(value) {
            return "\\bold{%{value.value}}";
        }
        public strikethrough(value) {
            return value.value;
        }
        public code(value) {
            return "\\monotype{\\pack{%{value.value}}}";
        }
        public image(value) {
            var check = checkInlineParam(value.alt);
            if (check.float.isString) {
                var floatPos = check.float;
                check.float = {};
                check.float[floatPos] = true;
                if (check.scale) {
                    check.scale = Double.parseDouble(check.scale);
                }
                value.opts = check;
                images_.push(value);
                return '';
            }
            return '\\image[%{value.alt}]{%{value.src}}';
        }
        public link(value) {
            return '';
        }
    }

    class BookParser {
        var title_, doc_;
        var list_ = [];
        var paragraph_ = [];
        var bquote_ = [];
        var opts_ = {};
        var ctx_ = {};
        var inline_ = new InlineMaker();
        private makeInlineText(values) {
            var str = '';
            inline_.reset();
            values.each { &(value):
                if (inline_[value.name].isFunction) {
                    str += inline_[value.name](value);
                }
            };
            return str;
        }
        private itemType(name) {
            switch (name) {
            case "list":
            case "checkedlist":
                return "item";
            case "orderedlist":
                return "enum";
            }
            return "item";
        }
        private flushDoc(noflush) {
            if (!noflush.list && list_.length() > 0) {
                var itemize = new Typesetting.Component.Itemize();
                var root = itemize.getRoot();
                var parent = [root];
                list_.each { &(item):
                    var l = item.level - 1;
                    var p = parent[l] || parent[-1];
                    var d = itemize.addItem(p, l, itemType(item.name), makeInlineText(item.values));
                    parent[item.level] = d;
                };
                doc_.apply(itemize);
                list_ = [];
            }
            if (!noflush.bquote && bquote_.length() > 0) {
                var text = "";
                bquote_.each { &(item):
                    text += makeInlineText(item.values);
                };
                doc_.apply(new Typesetting.Component.Abstract(text.trim()));
                bquote_ = [];
                ctx_.chapter = false;
            }
            if (!noflush.paragraph && paragraph_.length() > 0) {
                var p = paragraph_.join('\n\n');
                doc_.apply(new Typesetting.Component.Paragraph(p.trim()));
                paragraph_ = [];
            }
        }
        private checkParamCommand(values) {
            var r = false;
            values.each { &(value):
                if (value.name == 'html' && value.value.isString) {
                    var v = value.value.trim();
                    if (v.startsWith("<param ")) {
                        var m = v.match(/<param\s*(.+)="(.+)"\s*\/>/);
                        if (m.isDefined) {
                            opts_[m[1]] = m[2];
                        }
                        r = true;
                    }
                    if (/<pagebreak\s*\/>/.test(v)) {
                        flushDoc();
                        doc_.pageBreak();
                    }
                    r = true;
                }
            };
            return r;
        }
        private makeDocument() {
            opts_.style ??= "BookA4";
            doc_ = new Typesetting.Document(Typesetting.Style[opts_.style], { toc: true, lof: true, lot: true, xref: "book2.json" });

            if (title_) {
                var title = new Typesetting.Component.Title();
                title.setTitle(title_, Double.parseDouble(opts_.titleSize));
                if (opts_.author) {
                    title.setAuthor(opts_.author);
                }
                if (opts_.subtitle) {
                    title.setSubtitle(opts_.subtitle, Double.parseDouble(opts_.subtitleSize));
                }
                if (opts_.date) {
                    title.setDate(opts_.date);
                }
                doc_.apply(title);
                doc_.toc();
            }
        }
        private checkInlineParam(paramsText) {
            if (!paramsText.isString) {
                return;
            }
            var checker = paramsText.split(':');
            var res = { syntax: checker[0], lineNumber: true, box: Typesetting.BOX_SHADOW };
            if (checker.length() > 1) {
                var params = checker[1];
                params.split(',').each { &(param):
                    var e = param.split('=');
                    if (e.length() > 1) {
                        res[e[0]] = (Typesetting[e[1]] ?? (e[1] == "true" ? true : e[1] == "false" ? false : e[1]));
                    } else {
                        res[e[0]] = Typesetting[e[0]] ?? true;
                    }
                };
            }
            return res;
        }
        private finCommand() {
            ctx_.chapter = false;
        }
        private makeMathDocument(math, check) {
            if (check.label.isString) {
                var labels = check.label.split('/');
                labels.each { &(label):
                    var m = label.match(/([^\(]*)(?:\((.*)\))?/);
                    if (m.isDefined) {
                        if (m[2] == '') {
                            math.setLabel(m[1]);
                        } else {
                            var pos = Double.parseDouble(m[2]);
                            math.setLabel([m[1], pos]);
                        }
                    }
                };
            }
        }

        public heading(ast) {
            flushDoc();
            if (ast.level == 1) {
                title_ = makeInlineText(ast.values);
            }
            if (doc_.isUndefined) {
                if (ast.level != 2) {
                    return;
                }
                makeDocument();
            }
            switch (ast.level) {
            case 1: # ignore
                break;
            case 2:
                doc_.apply(new Typesetting.Component.Chapter(makeInlineText(ast.values)));
                ctx_.chapter = true;
                break;
            case 3:
                doc_.apply(new Typesetting.Component.Section(makeInlineText(ast.values)));
                break;
            case 4:
                doc_.apply(new Typesetting.Component.SubSection(makeInlineText(ast.values)));
                break;
            case 5:
                doc_.apply(new Typesetting.Component.SubSubSection(makeInlineText(ast.values)));
                break;
            }
        }
        public paragraph(ast) {
            flushDoc({ paragraph: true });
            if (checkParamCommand(ast.values)) {
                return;
            }
            if (doc_.isUndefined) {
                return;
            }
            var text = makeInlineText(ast.values);
            paragraph_.push(text);
            inline_.flush(doc_);
        }
        public horizontal(ast) {
            flushDoc();
            # TODO
            finCommand();
        }
        public code(ast) {
            flushDoc();
            var code;
            var check = checkInlineParam(ast.syntax);
            switch (check.syntax) {
            case 'math':
                code = new Typesetting.Component.Math(makeInlineText(ast.values).trim());
                makeMathDocument(code, check);
                break;
            default:
                code = new Typesetting.Component.Code(makeInlineText(ast.values).trim());
                if (check.lineNumber) {
                    code.showLineNumber();
                }
                if (check.box) {
                    code.showBox(check.box);
                }
                break;
            }
            doc_.apply(code);
            finCommand();
        }
        public blockquote(ast) {
            if (ctx_.chapter) {
                flushDoc({ bquote: true });
                bquote_.push(ast);
            } else {
                flushDoc();
                System.println(ast.toJsonString(true));
                finCommand();
            }
        }
        public list(ast) {
            flushDoc({ list: true });
            list_.push(ast);
        }
        public orderedlist(ast) {
            flushDoc({ list: true });
            list_.push(ast);
        }
        public checklist(ast) {
            flushDoc({ list: true });
            list_.push(ast);
        }
        public table(ast) {
            flushDoc();
            # TODO
            finCommand();
        }

        public dump() {
            flushDoc();
            finCommand();
            if (doc_.isUndefined) {
                return;
            }
            doc_.save("book2.pdf");
        }
    }

} # namespace Typesetting

var contents = File.load("examples/typesetting/KinxTT_jp.md");
var parser = new Typesetting.BookParser();
var ast = Markdown.BlockParser(contents);
ast.each { &(a):
    parser[a.name](a);
};
parser.dump();
