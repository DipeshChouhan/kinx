using Typesetting;
using typesetting.style.JBookA4;
using MarkdownParser;

namespace Typesetting {

    class InlineMaker {
        var images_ = [];
        private checkInlineParam(paramsText) {
            var res = {};
            paramsText.split(',').each { &(param):
                var e = param.split('=');
                if (e.length() > 1) {
                    res[e[0]] = e[1];
                } else {
                    res[e[0]] = true;
                }
            };
            return res;
        }
        public reset() {
            images_ = [];
        }
        public flush(doc) {
            images_.each { &(image):
                doc.apply(new Typesetting.Component.Image({
                    label: image.opts.label,
                    float: image.opts.float,
                    scale: image.opts.scale ?? 1.0,
                    caption: image.opts.caption,
                    file: image.src,
                }));
            };
            images_ = [];
        }

        public text(value) {
            return value.value;
        }
        public html(value) {
            return '';
        }
        public htmlcomment(value) {
            return '';
        }
        public em(value) {
            return "\\bold{%{value.value}}";
        }
        public italic(value) {
            return value.value;
        }
        public emitalic(value) {
            return "\\bold{%{value.value}}";
        }
        public strikethrough(value) {
            return value.value;
        }
        public code(value) {
            return "\\monotype{\\pack{%{value.value}}}";
        }
        public image(value) {
            var check = checkInlineParam(value.alt);
            if (check.float.isString) {
                var floatPos = check.float;
                check.float = {};
                check.float[floatPos] = true;
                if (check.scale) {
                    check.scale = Double.parseDouble(check.scale);
                }
                value.opts = check;
                images_.push(value);
                return '';
            }
            return '\\image[%{value.alt}]{%{value.src}}';
        }
        public link(value) {
            return '';
        }
    }

    class BookParser {
        var title_, doc_;
        var list_ = [];
        var opts_ = {};
        var inline_ = new InlineMaker();
        private makeInlineText(values) {
            var str = '';
            inline_.reset();
            values.each { &(value):
                if (inline_[value.name].isFunction) {
                    str += inline_[value.name](value);
                }
            };
            return str;
        }
        private checkParam(values) {
            var r = false;
            values.each { &(value):
                if (value.value.isString) {
                    var v = value.value.trim();
                    if (value.name == 'html' && v.startsWith("<param ")) {
                        var m = v.match(/<param\s*(.+)="(.+)"\s*\/>/);
                        if (m.isDefined) {
                            opts_[m[1]] = m[2];
                        }
                        r = true;
                    }
                }
            };
            return r;
        }
        public makeDocument() {
            opts_.style ??= "BookA4";
            doc_ = new Typesetting.Document(Typesetting.Style[opts_.style], { toc: true, lof: true, lot: true, xref: "book2.json" });

            if (title_) {
                var title = new Typesetting.Component.Title();
                title.setTitle(title_, Double.parseDouble(opts_.titleSize));
                if (opts_.author) {
                    title.setAuthor(opts_.author);
                }
                if (opts_.subtitle) {
                    title.setSubtitle(opts_.subtitle, Double.parseDouble(opts_.subtitleSize));
                }
                if (opts_.date) {
                    title.setDate(opts_.date);
                }
                doc_.apply(title);
                doc_.toc();
            }
        }
        private itemType(name) {
            switch (name) {
            case "list":
            case "checkedlist":
                return "item";
            case "orderedlist":
                return "enum";
            }
            return "item";
        }
        public flushList() {
            if (list_.length() == 0) {
                return;
            }
            var itemize = new Typesetting.Component.Itemize();
            var root = itemize.getRoot();
            var parent = [root];
            list_.each { &(item)
                var l = item.level - 1;
                var p = parent[l] || parent[-1];
                var d = itemize.addItem(p, l, itemType(item.name), makeInlineText(item.values));
                parent[item.level] = d;
            };
            doc_.apply(itemize);
            list_ = [];
        }
        private checkInlineParam(paramsText) {
            var res = { lineNumber: true, box: Typesetting.BOX_SHADOW };
            var checker = paramsText.split(':');
            if (checker.length() > 1) {
                var params = checker[1];
                params.split(',').each { &(param):
                    var e = param.split('=');
                    if (e.length() > 1) {
                        res[e[0]] = (Typesetting[e[1]] ?? (e[1] == "true"));
                    } else {
                        res[e[0]] = Typesetting[e[0]] ?? true;
                    }
                };
            }
            return res;
        }

        public heading(ast) {
            flushList();
            if (ast.level == 1) {
                title_ = makeInlineText(ast.values);
            }
            if (doc_.isUndefined) {
                if (ast.level != 2) {
                    return;
                }
                makeDocument();
            }
            switch (ast.level) {
            case 1: # ignore
                break;
            case 2:
                doc_.apply(new Typesetting.Component.Chapter(makeInlineText(ast.values)));
                break;
            case 3:
                doc_.apply(new Typesetting.Component.Section(makeInlineText(ast.values)));
                break;
            case 4:
                doc_.apply(new Typesetting.Component.SubSection(makeInlineText(ast.values)));
                break;
            case 5:
                doc_.apply(new Typesetting.Component.SubSubSection(makeInlineText(ast.values)));
                break;
            }
        }
        public paragraph(ast) {
            flushList();
            if (checkParam(ast.values)) {
                return;
            }
            if (doc_.isUndefined) {
                return;
            }
            var text = makeInlineText(ast.values);
            inline_.flush(doc_);
            doc_.apply(new Typesetting.Component.Paragraph(text));
        }
        public horizontal(ast) {
            flushList();
            # TODO
        }
        public code(ast) {
            flushList();
            var code = new Typesetting.Component.Code(makeInlineText(ast.values).trim());
            var check = checkInlineParam(ast.syntax);
            if (check.lineNumber) {
                code.showLineNumber();
            }
            if (check.box) {
                code.showBox(check.box);
            }
            doc_.apply(code);
        }
        public blockquote(ast) {
            flushList();
            # TODO
        }
        public list(ast) {
            list_.push(ast);
        }
        public orderedlist(ast) {
            list_.push(ast);
        }
        public checklist(ast) {
            list_.push(ast);
        }
        public table(ast) {
            flushList();
            # TODO
        }

        public dump() {
            flushList();
            # System.println("Title: ", title_);
            # opts_.keySet().each { &(key):
            #     System.println(key + ": ", opts_[key]);
            # };
            if (doc_.isUndefined) {
                return;
            }
            doc_.save("book2.pdf");
        }
    }

} # namespace Typesetting

var contents = File.load("examples/typesetting/KinxTT_jp.md");
var parser = new Typesetting.BookParser();
var ast = Markdown.BlockParser(contents);
ast.each { &(a):
    parser[a.name](a);
};
parser.dump();
